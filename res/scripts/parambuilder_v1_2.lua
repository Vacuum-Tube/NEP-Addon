--[[
ParamBuilder  -  https://www.transportfever.net/filebase/index.php?entry/5626-parambuilder/

Copyright (c)  2023  VacuumTube  -  https://www.transportfever.net/wsc/index.php?user/29264-vacuumtube/

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including the right to distribute and without limitation the rights to use, copy and/or modify
the Software, and to permit persons to whom the Software is furnished to do so, subject to the
following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial
portions of the Software.
--]]

local pb = {
	version = {
		major = 1,
		minor = 2,
	},
	date = "2023-05-14",
	copyright = "VacuumTube",
}
local file_src = debug.getinfo(1, 'S').source:match("/res/scripts/(.+)")
local this_file_should_be_located_in = "res/scripts/parambuilder_v${major}_${minor}.lua" % pb.version
assert(this_file_should_be_located_in=="res/scripts/"..file_src, 
	"ParamBuilder src file needs to be placed in '"..this_file_should_be_located_in.."' and should not be renamed!")

-- !!!   Do not edit this file   !!! 
-- Otherwise there are mod compatibility issues with different versions
-- Info & Help:  https://www.transportfever.net/filebase/index.php?entry/5626-parambuilder/


function pb.Slider(key,name,values,defaultIdx,tooltipORvandef,valuesTxt)
	return pb.Builder("SLIDER",key,name,values,defaultIdx,tooltipORvandef,valuesTxt)
end

function pb.Combobox(key,name,values,defaultIdx,tooltip,valuesTxt)
	return pb.Builder("COMBOBOX",key,name,values,defaultIdx,tooltip,valuesTxt)
end

function pb.Button(key,name,values,defaultIdx,tooltip,valuesTxt)
	return pb.Builder("BUTTON",key,name,values,defaultIdx,tooltip,valuesTxt)
end

function pb.IconButton(key,name,icons,values,defaultIdx,tooltip)
	return pb.Builder("ICON_BUTTON",key,name,values or icons,defaultIdx,tooltip,icons)  -- icons are values(txt) here, the icon names given to params.values
end

function pb.Checkbox(key,name,defaultCheck,tooltip)
	if defaultCheck==nil then
		defaultCheck = true
	end
	assert(type(defaultCheck)=="boolean", "defaultCheck should be boolean")
	return pb.Builder("CHECKBOX",key,name,{"false","true","dummy"},defaultCheck and 1 or 0,tooltip)
end


function pb.Builder(uiType,key,name,values,defaultIdx,tooltipORmodvandef,valuesTxt)
	assert(type(key)=="string", "key has to be a string")
	assert(type(name)=="string", "name has to be a string")
	assert(type(values)=="table", "name has to be a table")

	local defaultIndex = defaultIdx or 0
	assert(type(defaultIndex)=="number", "defaultIdx has to be a number")
	assert(defaultIndex >= 0, "invalid defaultIndex: ".. defaultIndex)
	local defaultBool = defaultIndex > 0
	local defaultValue = values[defaultIndex+1]
	assert(defaultValue, "No valid defaultValue! defaultIndex out of bound?")
	
	if valuesTxt==nil then
		valuesTxt = pb.strValues(values)
	elseif type(valuesTxt)=="string" then  -- format str
		valuesTxt = pb.strValues(values, valuesTxt)
	elseif type(valuesTxt)=="function" then
		valuesTxt = pb.strValues(values, valuesTxt)
	end
	assert(type(valuesTxt)=="table", "valuesTxt invalid type")
	assert(#valuesTxt==#values, "values and valuesTxt must have same length!")
	local defaultValueTxt = valuesTxt[defaultIndex+1]

	local tooltip = tooltipORmodvandef
	local moddefstr = string.format("%s %s: %s" , "Mod" , _("Default"), defaultValueTxt )
	if type(tooltipORmodvandef)=='number' then  -- use for mod settings that change vanilla config values
		local vandefstr = string.format("%s %s: %s\n", "Vanilla", _("Default"), tooltipORmodvandef )
		tooltip = vandefstr..moddefstr
	elseif tooltipORmodvandef==true then  -- show mod default as tooltip
		tooltip = moddefstr
	end
	assert(tooltip==nil or type(tooltip)=="string", "Invalid tooltip")
	
	local function printmsg(...)
		-- if not pb.dontprint then
			pb.printkey(key, ...)
		-- end
	end
	
	return {
		params = {
			uiType = uiType,
			key = key,
			name = name,
			tooltip = tooltip,
			values = valuesTxt,
			defaultIndex = defaultIndex,
		},
		values = values,
		defaultIndex = defaultIndex,
		defaultBool = defaultBool,
		defaultValue = defaultValue,
		defaultValueTxt = defaultValueTxt,
		getIndex = function(params)
			if params then
				local index = params[key]
				if type(index)~="number" then
					printmsg("WARNING: index not type number", "Index: ", index )
				end
				return index
			else
				printmsg("No params", "-> default index:", defaultIndex )
				return defaultIndex
			end
		end,
		getBool = function(params)
			if params then
				local index = params[key]
				if index then
					return index > 0
				else
					printmsg("No key", "-> default bool:", defaultBool )
					return defaultBool
				end
			else
				printmsg("No params", "-> default bool:", defaultBool )
				return defaultBool
			end
		end,
		getValue = function(params)
			if params then
				local index = params[key]
				if index then
					local val = values[index+1]
					if val==nil then
						printmsg("WARNING: No value for given index:", index, " Index out of bound? Duplicate key?")
					end
					return val
				else  -- key not exist. May happen if mod params has other keys, but this key not set yet
					printmsg("No key", "-> default value:", defaultValue )
					return defaultValue
				end
			else  -- should only happen if mod params not set yet
				printmsg("No params", "-> default value:", defaultValue )
				return defaultValue
			end
		end,
	}
end



function pb.range(start,enD,step)
	step = step or 1
	local r = {}
	for i = start,enD+step*0.001,step do  -- floating precision problem: make sure to include end
		table.insert(r, i)
	end
	return r
end

function pb.rangeSymm(enD,step)  -- better than range because of numeric precision around 0
	local r1 = pb.range(0,enD,step)
	local rs = {0}
	for k = 2,#r1 do 
		table.insert(rs, r1[k])
		table.insert(rs, 1, -r1[k])
	end
	return rs
end

function pb.strValues(values,formatStr)
	local s = {}
	for i,val in pairs(values) do
		if type(formatStr)=="string" then
			s[i] = string.format(formatStr, val)
		elseif type(formatStr)=="function" then
			s[i] = formatStr(val)
			assert(type(s[i])=="string", "result of formatStr function has to be string, but is: "..tostring(s[i]))
		else
			s[i] = tostring(val)
		end
	end
	return s
end


function pb.printmod(...)
	print(getCurrentModId(), ...)
end

function pb.printkey(key, ...)
	pb.printmod("key: "..key, ...)
end


return pb